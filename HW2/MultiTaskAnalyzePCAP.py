import requests
import os
import time
import json
import random
import subprocess
from concurrent.futures import ThreadPoolExecutor, as_completed

REST_URL = "http://localhost:8090"
CREATE_ENDPOINT = '/tasks/create/file'
VIEW_ENDPOINT = '/tasks/view'
REPORT_ENDPOINT = '/tasks/report'
PCAP_ENDPOINT = '/pcap/get'

VIRUS_FOLDER = "./out"
REPORT_FOLDER = "./Report"
HEADERS = {"Authorization": "Bearer BvcGk9DUHVaF340X38Tfxg"}
EXCEP_FOLDER = []

MAX_VM = 4
MAX_TYPE_COUNT = 120

lock = False


def handle_file(file_path, type):
    '''Function to handle each file'''
    global lock

    # lock prevent racing
    while lock:
        time.sleep(1)
    lock = True

    # Create task
    file = os.path.basename(file_path)
    print('File - : ' + str(file_path))
    with open(file_path, "rb") as virus:
        reqFiles = {
            "file": (file, virus),
        }
        form = {
            # "timeout": "120",
            "options": "procmemdump=yes,remotecontrol=yes,route=none"
        }
        r = requests.post(REST_URL + CREATE_ENDPOINT,
                          headers=HEADERS, files=reqFiles, data=form)
    if r.status_code != 200:
        print('Create Task Error: Status Code - ' + str(r.status_code))
        lock = False
        return
    else:
        taskId = r.json()["task_id"]
        print('TaskId: ' + str(taskId))
    # release lock
    lock = False

    # Check task status
    while True:
        time.sleep(10)
        # lock prevent racing
        while lock:
            time.sleep(1)
        lock = True
        r = requests.get(REST_URL + VIEW_ENDPOINT + '/' +
                         str(taskId), headers=HEADERS)

        if r.status_code != 200:
            print('Check Status Error: Status Code - ' + str(r.status_code))
            return
        else:
            status = r.json()["task"]["status"]
            print('ID: ' + str(taskId) + ' Task Status: ' + str(status))

            if status == 'reported':
                lock = False
                break
        # release lock
        lock = False

    # lock prevent racing
    while lock:
        time.sleep(1)
    lock = True
    # Get report
    r = requests.get(REST_URL + PCAP_ENDPOINT +
                     '/' + str(taskId), headers=HEADERS)

    if r.status_code != 200:
        print('Check Status Error: Status Code - ' + str(r.status_code))
    else:
        if not os.path.exists(REPORT_FOLDER + '/' + type):
            os.makedirs(REPORT_FOLDER + '/' + type)
        reportFileName = REPORT_FOLDER + '/' + type + '/' + file + '.pcap'

        with open(reportFileName, "w") as reportFile:
            reportFile.write(r.content)
        print('PCAP: ' + str(file))
        time.sleep(1)

    # release lock
    lock = False


def main():

    # Create a ThreadPoolExecutor
    with ThreadPoolExecutor(max_workers=MAX_VM) as executor:
        futures = []
        reported = []
        if not os.path.exists(REPORT_FOLDER):
            os.makedirs(REPORT_FOLDER)
        for root, dirs, files in os.walk(REPORT_FOLDER):
            for file in files:
                filename, _ = os.path.splitext(file)
                reported.append(filename)

        for root, dirs, files in os.walk(VIRUS_FOLDER):
            if root == VIRUS_FOLDER:
                continue
            dir = os.path.basename(root)
            if dir in EXCEP_FOLDER:
                continue
            dirCount = 0
            for file in files:
                dirCount += 1
                if file in reported:
                    print('skip ' + file)
                    continue
                file_path = os.path.join(root, file)
                futures.append(executor.submit(handle_file, file_path, dir))
                if dirCount >= MAX_TYPE_COUNT:
                    break

        # for root, dirs, files in os.walk(VIRUS_FOLDER):
        #     for file in files:
        #         if file in reported:
        #             print('skip ' + file)
        #             continue
        #         file_path = os.path.join(root, file)
        #         futures.append(executor.submit(handle_file, file_path))

        # Wait for all futures to complete
        for future in as_completed(futures):
            future.result()  # Getting the result will also re-raise any exceptions


if __name__ == '__main__':
    main()
