from scapy.all import *
import binascii
from PIL import Image
import numpy as np
import shutil
import os
from tqdm import tqdm

applicationLayer = ['DHCP','DNS','FTP','Gopher','HTTP','IMAP4','IRC','NNTP','XMPP','POP3','SIP','SMTP','SNMP','SSH','TELNET','RPC','RTCP','RTSP','TLS','SDP','SOAP','GTP','STUN','NTP']
SRC_FOLDER = './Hw2_ArDai_0430'
OUTPUT_FOLDER = './out'
OUTPUT_IMAGE_FOLDER = 'out_image'
RESULT_FOLDER = 'Result'
PCAP_RESULT = 'PCAP_Result'
IMG_RESULT = 'IMG_Result'
# DATASET_FOLDER_PATH = 'PCAP_dataset'
# tempPcapPath = 'PCAP_dataset'
tempPcapPath = 'pcap_folder'
LOG_PATH = 'log.txt'

IMAGE_SIZE = 15
isDataSorted = False

# get raw data
def extract_5tuple(packet):
    if 'IP' in packet:
        src_ip = packet['IP'].src
        dst_ip = packet['IP'].dst
        proto = packet['IP'].proto
        
        hex_str = bytes_hex(packet)
        srcPortStr = chr(hex_str[68]) + chr(hex_str[69]) + chr(hex_str[70]) + chr(hex_str[71])
        dstPortStr = chr(hex_str[72]) + chr(hex_str[73]) + chr(hex_str[74]) + chr(hex_str[75])
        tcpStr = chr(hex_str[46]) + chr(hex_str[47])
        returnStr = srcPortStr + dstPortStr + tcpStr
        
        if proto == 6:  # TCP
            if 'TCP' in packet:
                src_port = packet['TCP'].sport
                dst_port = packet['TCP'].dport
                # print('returnStr', returnStr)
                
                return (src_ip, src_port, dst_ip, dst_port, "TCP"), returnStr
        elif proto == 17:  # UDP
            if 'UDP' in packet:
                src_port = packet['UDP'].sport
                dst_port = packet['UDP'].dport
                
                return (src_ip, src_port, dst_ip, dst_port, "UDP"), returnStr
    return None, ''

def extract_5tuple_flows(packets):
    flows = {}
    for packet in packets:
        # print(str(packet))
        flow, outputStr = extract_5tuple(packet)
        if flow:
            flows.setdefault(flow, '')
            flows[flow] = outputStr
    
    if isDataSorted:
        flows = dict(sorted(flows.items(), key=lambda item: item[1]))
    return flows

def IsApplicationLayer(packets):
    # print(bytes(packets[0]))
    for packet in packets:
        pkt_str = str(packet)
        for app in applicationLayer:
            if app in pkt_str:
                return True
    return False

if __name__:
    if input('是否需要排列Flows? (Y/n)') == 'Y':
        isDataSorted = True
        
    HEX_BYTE_NUM = IMAGE_SIZE * IMAGE_SIZE * 2
    if not os.path.exists(SRC_FOLDER):
        os.makedirs(SRC_FOLDER)
    categoryList = os.listdir(SRC_FOLDER)
    if os.path.exists(OUTPUT_FOLDER):
        shutil.rmtree(OUTPUT_FOLDER)
    os.mkdir(OUTPUT_FOLDER)
    if os.path.exists(OUTPUT_IMAGE_FOLDER):
        shutil.rmtree(OUTPUT_IMAGE_FOLDER)
    os.mkdir(OUTPUT_IMAGE_FOLDER)
  
    if os.path.exists(LOG_PATH):
        os.remove(LOG_PATH)
    # wirte log
    big_counts = 0
    with open(LOG_PATH, 'w') as log:

        for category in tqdm(categoryList):
            img_count = 0
            log.write(f"{category}\n")
            os.mkdir(os.path.join(OUTPUT_FOLDER, category))
            os.mkdir(os.path.join(OUTPUT_IMAGE_FOLDER, category))

            fileList = os.listdir(os.path.join(SRC_FOLDER, category))
            for file in fileList:
                fileName = file.split('.')[0]
                os.mkdir(os.path.join(OUTPUT_FOLDER, category, fileName))
                pcapResultPath = os.path.join(OUTPUT_FOLDER, category, fileName, PCAP_RESULT)
                imgResultPath = os.path.join(OUTPUT_IMAGE_FOLDER, category, fileName)
                os.mkdir(pcapResultPath)
                # os.mkdir(imgResultPath)
                pcapPath = os.path.join(SRC_FOLDER, category, file)
                # pcapPath = tempPcapPath
                try:
                    packets = rdpcap(pcapPath)
                    if IsApplicationLayer(packets):
                    # if IsApplicationLayer(packets):
                        flow_counts = extract_5tuple_flows(packets)
                        # print(f"Number of Flows: {(flow_counts)}")
                        fileIndex = 0
                        txt = b''
                        imgOutPath = imgResultPath
                        Aflow = ""
                        for flow, outputStr in flow_counts.items():
                            
                            Aflow += outputStr
                            # # fileName = os.path.join(PCAP_RESULT, category, file, fileIndex)
                            # pcapOutPath = os.path.join(pcapResultPath, str(fileIndex))
                            # # print("Flow:", flow, "Count:", count)
                            
                            # # 寫成 pcap file
                            # with open(pcapOutPath + '.pcap', 'w') as res:
                            #     res.write(outputStr)
                            # fileIndex += 1
                            # # 讀取 binary 內容
                            # with open(pcapOutPath + '.pcap', 'rb') as out:
                            #     txt += out.read()

                        # print("=====================================")
                        # print(Aflow)
                        # binary 內容轉為 16 進制字串 (要拿來變成 28*28 pixel)
                        # hex_str = binascii.b2a_hex(txt).deco。e('unicode_escape')
                        # hex_str = hex_str[0:HEX_BYTE_NUM]
                        # if len(hex_str) < HEX_BYTE_NUM:
                        #     hex_zero = binascii.b2a_hex(b'\0').decode('unicode_escape')
                        #     addTime = (HEX_BYTE_NUM - len(hex_str)) // 2
                        #     for i in range(0, addTime):
                        #         hex_str += hex_zero
                        
                        hex_string = Aflow
                        hex_list = [int(hex_string[i:i+2], 16) for i in range(0, len(hex_string), 2)]
                        
                        width = IMAGE_SIZE
                        height = IMAGE_SIZE
                        if len(hex_list) < width * height:
                            hex_list += [0] * (width * height - len(hex_list))
                        elif len(hex_list) > width * height:
                            big_counts += 1
                            hex_list = hex_list[:width * height]
                        # 建立圖片
                        image = Image.new("L", (width, height))  # 建立一個灰度圖片

                        # 將像素值填入圖片
                        image.putdata(hex_list)

                        # 顯示圖片
                        # image.show()                          
                        # save image
                        image.save(os.path.join(imgOutPath + '.png'))
                    else:
                        # write log
                        log.write(f"{fileName}\n")
                        print(f"file ${pcapPath} doesn't content application layer.")
                except:
                    log.write(f"Error: open pcap file in -> {fileName}\n")
            log.write(f'Number of Images: {img_count}/{len(fileList)}\n')            
    print(f"Big Counts: {big_counts}")