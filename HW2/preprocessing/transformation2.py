from pathlib import Path
from scapy.all import *
import shutil
import numpy as np
from PIL import Image
from tqdm import tqdm


# Path Parameter
PCAP_FOLDER_PATH = "dataset"
PCAP_OUTPUT_PATH = "pcapOutput"
IMAGE_OUTPUT_PATH = "imageOutput"

def processPCAP(scapyCap, flows: set):
    for packet in scapyCap:
        if TCP in packet:
            flow = (
                packet[IP].src,
                packet[TCP].sport,
                packet[IP].dst,
                packet[TCP].dport,
                "TCP"
            )
            flows.add(flow)
        if UDP in packet:
            flow = (
                packet[IP].src,
                packet[UDP].sport,
                packet[IP].dst,
                packet[UDP].dport,
                "UDP"
            )
            flows.add(flow)

def save_flow_to_pcap(scapyCap, flow, output_file):
    extracted_packets = []
    src_ip, src_port, dst_ip, dst_port, protocol = flow
    for packet in scapyCap:
        if (IP in packet and packet[IP].src == src_ip and packet[IP].dst == dst_ip and
            UDP in packet and packet[UDP].sport == src_port and packet[UDP].dport == dst_port):
            extracted_packets.append(packet)
        elif (IP in packet and packet[IP].src == src_ip and packet[IP].dst == dst_ip and
            TCP in packet and packet[TCP].sport == src_port and packet[TCP].dport == dst_port):
            extracted_packets.append(packet)
    wrpcap(output_file, extracted_packets)

def pcap_to_grayscale_image(pcap_folder, output_folder):
    width = 15
    height = 15
    for pcap_file in Path(pcap_folder).glob("*"):
        output_image = f"{output_folder}\\{pcap_file.stem}.png"
        with open(pcap_file, 'rb') as file:
            pcap_data = file.read()

        # If the length of pcap_data is greater than width * height (784), truncate it
        if len(pcap_data) > width * height:
            pcap_data = pcap_data[:width * height]
        # If the length of pcap_data is less than width * height (784), pad it with zeros
        elif len(pcap_data) < width * height:
            pcap_data += bytes([0] * (width * height - len(pcap_data)))
        
        grayscale_values = [int(byte * 255 / 255) for byte in pcap_data]
        # Reshape the grayscale values to match the shape of the image
        array = np.array(grayscale_values).reshape((height, width)).astype(np.uint8)
        image = Image.fromarray(array, 'L')
        image.save(output_image)

def load_images(folder_path):
    images = []
    for filename in os.listdir(folder_path):
        image_path = os.path.join(folder_path, filename)
        if os.path.isfile(image_path):
            img = Image.open(image_path)
            images.append(img)
    return images

def create_collage(images):
    num = 4
    # Create a blank image to store the collage
    collage_width = images[0].width * num
    collage_height = images[0].height * num
    collage = Image.new('RGB', (collage_width, collage_height))
    
    # Paste each image into the collage
    for i in range(num):
        for j in range(num):
            index = i * num + j
            collage.paste(images[index], (j * images[0].width, i * images[0].height))
    
    return collage

def combine_image(image_input, file_name):
    images = load_images(Path(image_input, file_name))
    if len(images) > 16: 
        resultImage = create_collage(images)
        # remove
        resultImage.save(Path(image_input, file_name+".png"))

if __name__ == "__main__":
    # read pcap_folder
    if Path(PCAP_OUTPUT_PATH).exists():
        shutil.rmtree(Path(PCAP_OUTPUT_PATH))
    Path(PCAP_OUTPUT_PATH).mkdir()
    if Path(IMAGE_OUTPUT_PATH).exists():
        shutil.rmtree(Path(IMAGE_OUTPUT_PATH))
    Path(IMAGE_OUTPUT_PATH).mkdir()

    for category in tqdm(Path(PCAP_FOLDER_PATH).iterdir()):
        Path(PCAP_OUTPUT_PATH, category.name).mkdir()
        Path(IMAGE_OUTPUT_PATH, category.name).mkdir()
        # print(f"Category ----> :{category.name}")
        for file in Path(category).glob("*"):
            if Path(PCAP_OUTPUT_PATH, category.name, file.stem).exists():
                shutil.rmtree(Path(PCAP_OUTPUT_PATH, category.name, file.stem))
            Path(PCAP_OUTPUT_PATH, category.name, file.stem).mkdir()
            if Path(IMAGE_OUTPUT_PATH, category.name, file.stem).exists():
                shutil.rmtree(Path(IMAGE_OUTPUT_PATH, category.name, file.stem))
            Path(IMAGE_OUTPUT_PATH, category.name, file.stem).mkdir()
            scapyCap = rdpcap(str(file))
            # 將該檔案的所有封包整理到 set 裡面
            flows = set()
            processPCAP(scapyCap, flows)
            # save each flow to a pcap file
            count = 0
            for flow in flows:
                save_flow_to_pcap(scapyCap, flow, f"{PCAP_OUTPUT_PATH}\\{category.name}\\{file.stem}\\{file.stem}_{count}.pcap")
                count += 1
            pcap_to_grayscale_image(f"{PCAP_OUTPUT_PATH}\\{category.name}\\{file.stem}",f"{IMAGE_OUTPUT_PATH}\\{category.name}\\{file.stem}")
            combine_image(f"{IMAGE_OUTPUT_PATH}\\{category.name}", file.stem)
            shutil.rmtree(Path(IMAGE_OUTPUT_PATH, category.name, file.stem))
    # read pcap_output_folder

    # output image