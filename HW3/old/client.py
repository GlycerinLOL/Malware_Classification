# client.py
import flwr as fl
import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import datasets, transforms
from torch.utils.data import DataLoader, random_split
from collections import OrderedDict
from Model import MalwareCNN
import warnings
import argparse

warnings.filterwarnings("ignore", category=UserWarning)

class MalwareClient(fl.client.NumPyClient):
    def __init__(self, model, train_loader, val_loader, device):
        self.model = model
        self.train_loader = train_loader
        self.val_loader = val_loader
        self.device = device
        self.model.to(device)
        self.criterion = nn.CrossEntropyLoss()
        self.optimizer = optim.Adam(self.model.parameters(), lr=0.001)

    def get_parameters(self, config):
        return [val.cpu().numpy() for _, val in self.model.state_dict().items()]

    def set_parameters(self, parameters):
        params_dict = zip(self.model.state_dict().keys(), parameters)
        state_dict = OrderedDict({k: torch.tensor(v) for k, v in params_dict})
        self.model.load_state_dict(state_dict)

    def fit(self, parameters, config):
        self.set_parameters(parameters)
        self.model.train()
        for X, y in self.train_loader:
            X, y = X.to(self.device), y.to(self.device)
            self.optimizer.zero_grad()
            output = self.model(X)
            loss = self.criterion(output, y)
            loss.backward()
            self.optimizer.step()
        return self.get_parameters(config={}), len(self.train_loader.dataset), {}

    def evaluate(self, parameters, config):
        self.set_parameters(parameters)
        self.model.eval()
        total_loss = 0.0
        correct = 0
        with torch.no_grad():
            for X, y in self.val_loader:
                X, y = X.to(self.device), y.to(self.device)
                output = self.model(X)
                total_loss += self.criterion(output, y).item()
                pred = output.argmax(dim=1, keepdim=True)
                correct += pred.eq(y.view_as(pred)).sum().item()
        accuracy = correct / len(self.val_loader.dataset)
        return float(total_loss), len(self.val_loader.dataset), {"accuracy": accuracy}

def load_data(client_id):
    # Simulated unique data partitioning logic for demonstration
    transform = transforms.Compose([
        transforms.Resize((40, 40)),
        transforms.Grayscale(),
        transforms.ToTensor(),
    ])
    dataset = datasets.ImageFolder(root=f'datasets/pcap_gray_img_15', transform=transform)
    train_size = int(0.7 * len(dataset))
    val_size = len(dataset) - train_size
    train_dataset, val_dataset = random_split(dataset, [train_size, val_size])
    train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
    val_loader = DataLoader(val_dataset, batch_size=32, shuffle=False)
    return train_loader, val_loader

# #############################################################################
# 2. Federation of the pipeline with Flower
# #############################################################################

# Get partition id
parser = argparse.ArgumentParser(description="Flower")
parser.add_argument(
    "--partition-id",
    choices=[0, 1],
    default=0,
    type=int,
    help="Partition of the dataset divided into 2 iid partitions created artificially.",
)
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
client_id = parser.parse_known_args()[0].partition_id
print(f"Client ID: {client_id}")
train_loader, val_loader = load_data(client_id)
model = MalwareCNN(num_classes=6)

def client_fn(cid: str):
    """Create and return an instance of Flower `Client`."""
    return MalwareClient().to_client()

# Flower ClientApp
app = fl.client.ClientApp(
    client_fn=client_fn,
)


if __name__ == "__main__":
    # client_id = input("Enter the client ID (1, 2, or 3): ")  # Manually specify or automate for real deployment
    from flwr.client import start_client
    start_client(server_address="localhost:8080",
                 client=MalwareClient(model, train_loader, val_loader, device).to_client())
